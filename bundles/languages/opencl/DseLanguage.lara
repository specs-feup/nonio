import DseLanguageBase;
import DseLanguageResources;
import LaradSetup;
import dse.metrics.DseMetrics;
import lara.Io;
import lara.util.DataStore;
import clava.util.ClavaDataStore;
import weaver.WeaverOptions;


/**
 * State to preserve between calls
 */
DseLanguage._weavedFolder = undefined;
DseLanguage._srcNoTiming = undefined;
DseLanguage._launcherFilesToCompile = [];
DseLanguage._verificationFilesToCompile = [];
DseLanguage._kernelFilesToCompile = [];
DseLanguage._baseSourceFolder = "clava_src";

 
/*** PUBLIC API IMPLEMENTATION ***/
 
DseLanguage.clean = function() {
	// Files that can be generated by DseLanguage
	var files = Io.getPaths("./", "main_verify.c", "function.cl", "main_wtiming.c");

	for(var file of files) {
		Io.deleteFile(file);
	}
	
	Io.deleteFolder(DseLanguage._baseSourceFolder);
	Io.deleteFolder("clava_timed");
	// 
	//"clava_src");
	//DsePlatform._weavedFolder = "clava_timed";

}
 
/**
 * OpenCL implementation of DseLanguage
 *
 * @return {lara.util.DataStore} The DataStore that should be used to call the weaver.
 */
 DseLanguage.prepareCodeForInstrumentation = function() {
	println("Preparing code for instrumentation...");
	
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN) {
		return this._prepareCodeC();
	}
	
	throw "DseLanguage.prepareCodeForInstrumentation: case not defined '" + codeType + "'";
	
}

DseLanguage.prepareCodeForCompilation = function() {
	println("Preparing code for compilation...");
	
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN) {
		return this._prepareCodeForCompilationC();
	}
	
	throw "DseLanguage.prepareCodeForCompilation: case not defined '" + codeType + "'";
}

DseLanguage.getLauncherFilesToCompile = function() {
	var codeType = this._getCodeType();


	if(codeType === this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN) {
		return this._getLauncherFilesToCompileC();
	}
	
	throw "DseLanguage.getLauncherFilesToCompile: case not defined '" + codeType + "'";
}

DseLanguage.getVerificationFilesToCompile = function() {
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN) {
		return this._getVerificationFilesToCompileC();
	}
	
	throw "DseLanguage.getVerificationFilesToCompile: case not defined '" + codeType + "'";
}

DseLanguage.getKernelFilesToCompile = function() {
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN) {
		return this._getKernelFilesToCompileC();
	}
	
	throw "DseLanguage.getKernelFilesToCompile: case not defined '" + codeType + "'";
}

/*** PRIVATE CODE FOR DSELANGUAGE ***/



DseLanguage.CodeTypeEnum = {
  CL_FILE_WITH_SEPARATE_C_MAIN: 1
};

DseLanguage._getCodeType = function() {
	if(typeof LaradSetup.sourceFile !== "string") {
		throw "DseLanguage.prepareCode: currently only support 'sourceFile' parameters that are strings for language '" + LaradSetup.language + "'";
	}

	if(Io.isFolder(LaradSetup.sourceFile)) {
		throw "DseLanguage.prepareCode: currently does not support 'sourceFile' parameters that are folders for language '" + LaradSetup.language + "'";	
	}
	
	if(!Io.isFile(LaradSetup.sourceFile)) {
		throw "DseLanguage.prepareCode: file '" + LaradSetup.sourceFile + "' does not exist.";
	}
	
	if(!LaradSetup.sourceFile.endsWith(".cl")) {
		throw "DseLanguage.prepareCode: currently does not support 'sourceFile' parameters that are files of type '.cl' for language '" + LaradSetup.language + "'";
	}
	
	// Compiling single c file
	return this.CodeTypeEnum.CL_FILE_WITH_SEPARATE_C_MAIN;
}

DseLanguage._prepareCodeC = function() {
	println("--------- Prepare code C");

	// Delete files
	Io.deleteFiles("main_verify.c", "main_wtiming.c", "main_notiming.c", "function.cl", "include.h");
	
	// Clear list of files
	DseLanguage._launcherFilesToCompile = [];
	DseLanguage._kernelFilesToCompile = [];
	
	var filenameNoExt = Io.removeExtension(LaradSetup.sourceFile);
	var funcname = Io.removeExtension(Io.getPath(LaradSetup.sourceFile).getName());
	
	// Copy main verify, if present
	var verifySrc = filenameNoExt + "_verify.c";
	if(Io.isFile(verifySrc)) {
		Io.copyFile(filenameNoExt + "_verify.c", "main_verify.c");
		LaradSetup.isVerificationSeparated = true;
		DseLanguage._verificationFilesToCompile.push("main_verify.c");
	}

	Io.copyFile(LaradSetup.sourceFile, "function.cl");
        DseLanguage._kernelFilesToCompile.push("function.cl");

	if(LaradSetup.alreadyInstrumented) {
		var instrumentedMainFile = filenameNoExt + "_main.c";
		if(!Io.isFile(instrumentedMainFile)) {
			throw "DseLanguage._prepareCodeC: Could not find already instrumented main '"+ instrumentedMainFile + "'";
		}
		
		DseLanguage._launcherFilesToCompile.push(instrumentedMainFile);	
println("LAUNCHER FILES:" + DseLanguage._launcherFilesToCompile);
		return undefined;
	}

	var wovenSrc = Io.mkdir(DseLanguage._baseSourceFolder);
	DsePlatform._weavedFolder = "clava_timed";

	DseLanguage._srcNoTiming = Io.getPath(wovenSrc, "main_notiming.c");
	Io.copyFile(filenameNoExt + "_main.c", DseLanguage._srcNoTiming);
	
	// Create aspect code that will provide the $start and $end join points for instrumentation based on pragmas	
	var sectionProviderCode = this._buildInstrumentPointsCode();
	var sectionProviderName = this._getInstrumentPointsName();
	
	var mainAspectFile = DseMetrics.buildInstrumentationCode(wovenSrc, LaradSetup.metrics, sectionProviderName, sectionProviderCode);
	
	var data = new ClavaDataStore();
	// TODO: Replace the 'put' methods with methods in the objecy ClavaDataStore, to be easier to use
	data.put("aspect", mainAspectFile);
	data.put("workspace", FileList.newInstance(wovenSrc.getAbsolutePath()));
	data.put("Weaved code foldername", DsePlatform._weavedFolder);
	data.put("C/C++ Standard", Standard.getEnumHelper().fromValue("c99"));	
	//data.put("bundle_tags", Clava.getData().get("bundle_tags"));
	data.put("bundle_tags", WeaverOptions.getData().get("bundle_tags"));	

	data.put("Disable Clava Info", true);

	return data;
}

DseLanguage._buildInstrumentPointsCode = function() {
	return DseLanguageResources.getString("SectionProvider.lara");
}

DseLanguage._getInstrumentPointsName = function() {
	return "SectionProvider";
}

DseLanguage._prepareCodeForCompilationC = function() {

	if(!LaradSetup.alreadyInstrumented) {
		//var weavedMain = Io.getPath(DsePlatform._weavedFolder, "main_notiming.c");	// same name after weaving
		var weavedMainFilepath = Io.getPath(DseLanguage._baseSourceFolder, "main_notiming.c");
		var weavedMain = Io.getPath(DsePlatform._weavedFolder, weavedMainFilepath);
	
	
		Io.copyFile(weavedMain, "main_wtiming.c");
		DseLanguage._launcherFilesToCompile.push("main_wtiming.c");
	}
	else {
		var filenameNoExt = Io.removeExtension(LaradSetup.sourceFile);
		var instrumentedMainFile = filenameNoExt + "_main.c";
		if(!Io.isFile(instrumentedMainFile)) {
			throw "DseLanguage._prepareCodeC: Could not find already instrumented main '"+ instrumentedMainFile + "'";
		}

		DseLanguage._launcherFilesToCompile.push(instrumentedMainFile);
	}

	Io.deleteFiles("main_notiming.c", DseLanguage._srcNoTiming, weavedMain);



		// Já está na função 'DseLanguage._prepareCodeC()'
/*
        // Copy main verify, if present (is this necessary now?)
        var verifySrc = filenameNoExt + "_verify.c";
        if(Io.isFile(verifySrc)) {
                Io.copyFile(filenameNoExt + "_verify.c", "main_verify.c");
                LaradSetup.isVerificationSeparated = true;
                DseLanguage._verificationFilesToCompile.push("main_verify.c");
        }


	Io.copyFile(LaradSetup.sourceFile, "function.cl");
        DseLanguage._kernelFilesToCompile.push("function.cl");
*/


}

DseLanguage._getLauncherFilesToCompileC = function() {
	return DseLanguage._launcherFilesToCompile;
}

DseLanguage._getVerificationFilesToCompileC = function() {
	return DseLanguage._verificationFilesToCompile;
}

DseLanguage._getKernelFilesToCompileC = function() {
	return DseLanguage._kernelFilesToCompile;
}


