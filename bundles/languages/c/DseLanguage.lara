import DseLanguageBase;
import DseLanguageResources;
import LaradSetup;
import dse.metrics.DseMetrics;
import lara.Io;
import lara.Strings;
import lara.util.DataStore;
import weaver.WeaverOptions;
import clava.util.ClavaDataStore;

/**
 * State to preserve between calls
 */
DseLanguage._weavedFolder = undefined;
DseLanguage._srcNoTiming = undefined;
DseLanguage._launcherFilesToCompile = [];
DseLanguage._verificationFilesToCompile = [];
DseLanguage._kernelFilesToCompile = [];
DseLanguage._baseSourceFolder = "clava_src";
 
/*** PUBLIC API IMPLEMENTATION ***/
 
DseLanguage.clean = function() {
	// Files that can be generated by DseLanguage
	var files = Io.getPaths("./", "main_verify.c", "function.c", "main_wtiming.c");

	for(var file of files) {
		Io.deleteFile(file);
	}
	
	//Io.deleteFolder("clava_src");
	Io.deleteFolder(DseLanguage._baseSourceFolder);
	Io.deleteFolder("clava_timed");
	// 
	//"clava_src");
	//DsePlatform._weavedFolder = "clava_timed";

}
 
/**
 * C implementation of DseLanguage
 *
 * @return {lara.util.DataStore} The DataStore that should be used to call the weaver.
 */
 DseLanguage.prepareCodeForInstrumentation = function() {
	println("Preparing code for instrumentation...");
	
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN) {
		return this._prepareCodeC();
	}
	
	throw "DseLanguage.prepareCodeForInstrumentation: case not defined '" + codeType + "'";
	
}

DseLanguage.prepareCodeForCompilation = function() {
	println("Preparing code for compilation...");
	
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN) {
		return this._prepareCodeForCompilationC();
	}
	
	throw "DseLanguage.prepareCodeForCompilation: case not defined '" + codeType + "'";
}

DseLanguage.getLauncherFilesToCompile = function() {
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN) {
		return this._getLauncherFilesToCompileC();
	}
	
	throw "DseLanguage.getLauncherFilesToCompile: case not defined '" + codeType + "'";
}

DseLanguage.getVerificationFilesToCompile = function() {
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN) {
		return this._getVerificationFilesToCompileC();
	}
	
	throw "DseLanguage.getVerificationFilesToCompile: case not defined '" + codeType + "'";
}

DseLanguage.getKernelFilesToCompile = function() {
	var codeType = this._getCodeType();

	if(codeType === this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN) {
		return this._getKernelFilesToCompileC();
	}
	
	throw "DseLanguage.getKernelFilesToCompile: case not defined '" + codeType + "'";
}

/*** PRIVATE CODE FOR DSELANGUAGE ***/



DseLanguage.CodeTypeEnum = {
  C_FILE_WITH_SEPARATE_MAIN: 1
};

DseLanguage._getCodeType = function() {
	if(typeof LaradSetup.sourceFile !== "string") {
		throw "DseLanguage.prepareCode: currently only support 'sourceFile' parameters that are strings for language '" + LaradSetup.language + "'";
	}

	if(Io.isFolder(LaradSetup.sourceFile)) {
		throw "DseLanguage.prepareCode: currently does not support 'sourceFile' parameters that are folders for language '" + LaradSetup.language + "'";	
	}
	
	if(!Io.isFile(LaradSetup.sourceFile)) {
		throw "DseLanguage.prepareCode: file '" + LaradSetup.sourceFile + "' does not exist.";
	}
	
	if(!LaradSetup.sourceFile.endsWith(".c")) {
		throw "DseLanguage.prepareCode: currently does not support 'sourceFile' parameters that are files of type '.c' for language '" + LaradSetup.language + "'";
	}
	
	// Compiling single c file
	return this.CodeTypeEnum.C_FILE_WITH_SEPARATE_MAIN;
}

DseLanguage._prepareCodeC = function() {
	// Delete files
	Io.deleteFiles("main_verify.c", "main_wtiming.c", "main_notiming.c", "function.c", "include.h");
	
	// Clear list of files
	DseLanguage._launcherFilesToCompile = [];
	DseLanguage._kernelFilesToCompile = [];
	
	// Add extra sources to kernel files to compile
/*
	for(var extraSource of DseLanguage.getExtraSources()) {
		DseLanguage._kernelFilesToCompile.push(extraSource);
	}
	*/
	
	var filenameNoExt = Io.removeExtension(LaradSetup.sourceFile);
	var funcname = Io.removeExtension(Io.getPath(LaradSetup.sourceFile).getName());
	
	// Copy main verify, if present
	var verifySrc = filenameNoExt + "_verify.c";
	if(Io.isFile(verifySrc)) {
		Io.copyFile(filenameNoExt + "_verify.c", "main_verify.c");
		LaradSetup.isVerificationSeparated = true;
		DseLanguage._verificationFilesToCompile.push("main_verify.c");
	}
	
	var wovenSrc = Io.mkdir(DseLanguage._baseSourceFolder);
	DsePlatform._weavedFolder = "clava_timed";

	DseLanguage._srcNoTiming = Io.getPath(wovenSrc, "main_notiming.c");
	Io.copyFile(filenameNoExt + "_main.c", DseLanguage._srcNoTiming);
	Io.copyFile(LaradSetup.sourceFile, "function.c");
	DseLanguage._verificationFilesToCompile.push("function.c");
	DseLanguage._kernelFilesToCompile.push("function.c");
	
	// Create aspect code that will provide the $start and $end join points for instrumentation based on pragmas	
	var sectionProviderCode = this._buildInstrumentPointsCode();
	var sectionProviderName = this._getInstrumentPointsName();
	
	var mainAspectFile = DseMetrics.buildInstrumentationCode(wovenSrc, LaradSetup.metrics, sectionProviderName, sectionProviderCode);
	
	var data = new ClavaDataStore();
	//var data = Clava.getData().copy();
	
	// TODO: Replace the 'put' methods with methods in the objecy ClavaDataStore, to be easier to use
	data.put("aspect", mainAspectFile);
	data.put("workspace", FileList.newInstance(wovenSrc.getAbsolutePath()));
	data.put("Weaved code foldername", DsePlatform._weavedFolder);
	data.put("C/C++ Standard", Standard.getEnumHelper().fromValue("c99"));
	//data.put("bundle_tags", Clava.getData().get("bundle_tags"));
    data.put("bundle_tags", WeaverOptions.getData().get("bundle_tags"));	
	
	data.put("Disable Clava Info", true);
	
	// Add extra compilation flags
	var extraFlags = LaradSetup.getCompilerFlags();
	if(!Strings.isEmpty(extraFlags)) {
		data.put("Compiler Flags", extraFlags);
	}

	return data;
}

DseLanguage._buildInstrumentPointsCode = function() {
	return DseLanguageResources.getString("SectionProvider.lara");
}

DseLanguage._getInstrumentPointsName = function() {
	return "SectionProvider";
}

DseLanguage._prepareCodeForCompilationC = function() {

	//var weavedMain = Io.getPath(DsePlatform._weavedFolder, "main_notiming.c");
	var weavedMainFilepath = Io.getPath(DseLanguage._baseSourceFolder, "main_notiming.c");
	var weavedMain = Io.getPath(DsePlatform._weavedFolder, weavedMainFilepath);
	
	Io.copyFile(weavedMain, "main_wtiming.c");
	DseLanguage._launcherFilesToCompile.push("main_wtiming.c");
	
	// Add extra includes
	for(var extraInclude of DseLanguage.getExtraIncludes()) {
		DseLanguage._launcherFilesToCompile.push("-I"+extraInclude);
	}
	/*
	// Add extra sources
	for(var extraSource of DseLanguage.getExtraSources()) {
		DseLanguage._launcherFilesToCompile.push(extraSource);
	}
	*/

	Io.deleteFiles("main_notiming.c", DseLanguage._srcNoTiming, weavedMain);
}

DseLanguage._getLauncherFilesToCompileC = function() {
	return DseLanguage._launcherFilesToCompile;
}

DseLanguage._getVerificationFilesToCompileC = function() {
	return DseLanguage._verificationFilesToCompile;
}

DseLanguage._getKernelFilesToCompileC = function() {
	return DseLanguage._kernelFilesToCompile;
}


